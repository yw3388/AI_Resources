##cpu
https://stanford.edu/~shervine/blog/pytorch-how-to-generate-data-parallel

cpu/cuda: conda install numba cudatoolkit pyculib

## from stackoverflow
RuntimeError: size mismatch, m1: [a x b], m2: [c x d]
all you have to care is b=c and you are done:

m1 is [a x b] which is [batch size x in features]

m2 is [c x d] which is [in features x out features]
https://pytorch.org/docs/master/generated/torch.nn.Linear.html#torch.nn.Linear


ValueError: attempted relative import beyond top-level package


##from website
class construction
assignment perfom on variables, objects in memory
function calls return objects

self.hunger = hunger
self.get_hunger(): return self.hunger

constructor: 
constructor overloading:
no parameter is no parameter
this.n = N(parameter)

this in front of the field name: this.number is not necessary. 

##cnn
convnet: width, height, depth
every layer has a simple api

##convolutional layer, pooling layer, fully-connected layer
INPUT: width, height, three channels
CONV: weight, regions connected to input, filters
relu: activation max(0, x)
pool: width, height
fc: fully connected layer


https://www.youtube.com/watch?v=Li5sVEXTIJw

Activation: gate to activate or not
softmax: to proba, then choose max to give output

Feed forward neural network--一种归一化

结构性数据与非结构性数据
convolution: 
a, b, 1
就view改成b， a， -1


torch.nn is nn.Module
apply fn recursively to every submodule
buffers: recurse is True


for name, buf in self.named_buffers():
  if name in ['running_var']:
  print(buf.size())
  
 for name, module in model.named_children():
    if name in ['conv4']:
      print(module)
      
  for name, param in named_parameters():
    if name in ['bias']:
        param.size()
        
        
        
        
###webscrapping and downloading data
Your bottleneck is probably that you write the file to disk first and then read it again (I/O). 
If the file does not exceed your machines random access memory, decompressing the file on the fly in memory might be a faster option
json.gzip



decompression from gzip pkg

read_csv(compression = 'gzip')


###decode, Stringio
Bytes flow:

.json() easy

shrimpy

##pandas.read_clipboard(sep='\\s+', **kwargs)[source]
Read text from clipboard and pass to read_csv.

Parameters
sepstr, default ‘s+’
A string or regex delimiter. The default of ‘s+’ denotes one or more whitespace characters.

**kwargs
See read_csv for the full argument list.

Returns
DataFrame
A parsed DataFrame object.


###DL
https://www.kaggle.com/kanncaa1/deep-learning-tutorial-for-beginners
https://www.kaggle.com/kanncaa1/pytorch-tutorial-for-deep-learning-lovers
https://www.kaggle.com/arunkumarramanan/awesome-deep-learning-with-cnn-mnist-classifier
https://github.com/yw3388/awesome-deeplearning-resources

Blogs: 


/[+-]?\d+/ integers
/[+-]?\d+\./ 1., 321.
/[+-]?\.\d+/ .1, .234
/[+-]?\d+\.\d+/ 1.0

/[+-]?(\d+\.\d+|\d+\./
|\.\d+)/


find floats and integers in string
'\d*\.?\d+'


##@property
getter and setter:
add constraints in setters

makes a property object temperature. 
Simply put, property attaches some code to the member attribute accesses.
In Python, property() is a built-in function that creates and returns a property object. 
A property object has three methods, getter(), setter(), and deleter() 


define:
t = property(get_method, set_method)
any method call t will call get_method
any method assign value to t will call set_method
get and set: change attributes as self.__attribute

为什么用properties
所有属性在Python中都是公共的。以下划线或两个下划线开头的名称只是一个警告，即给定的属性是一个实现细

@property
@p.setter
getter and setter hide in attributes


属性的缺点：
很难处理异常值
比如我刚刚想pass parameters到一个setter中
但是error了
就会报错：recursion error， exceed number 
非常无益的回溯(

好处：
项目小的时候不想改变端口，仅仅数据改变，
只需要call类的成员即可，直接成员访问
用property改一些属性（pass parameter）

可以pythonic用来装逼



__method__: you don't use it
def __method(self): __避免被subclass overridden
_: 单行线is a property, and it's part of the API,


##liNUX
vim test.html
$pwd
$cd
$cd ..
$ls -la
$ mkdir create new directory
$cat : output the contents of file
$ rm <file>
$ rm -r <directory>
$mv <file><filenew>
$cp <file> <directory>: copy file to existing files ocerwriting an file
$cp -r <directory><directory2>
$ touch file: udpate file access and modification time 
$ chmod -R 600 <directory>
change permission to 600
$ find <dir> -name "<file>"
'*'


###When I find there are wheels and packages already on github, my time and work is like a bunch of shit, yea...(
git push 
git pull
git checkout -b "new-branch"
git add
git commit -m 
git commit -a
git push origin master (changed??)
git checkout -b <branchname>


##arguments and parameters
improt argparse
 parser = argparse.ArgumentParser()
 parser.add_argument('ech')
 parser.parse_args()


parser = argparse.ArgumentParser()
groupgroup = parser.add_mutually_exclustive_group()
group.add_argument('-v', '--versbose')
group.add_argument('-q', '--quiet')
parser.add_argument('x', type = int, help = 'the base')
parser.add_argument('y', type = int, help = 'the exponent')
args = parser.parse_args()
answer = args.x * args.y

if args.quiet:
    print (answer)
    
    
   [-h][-v|-q] xy
   
   
 ##叫parse的inner function是什么developer的命名标准吗
 ##叫parse的inner function是什么developer的命名标准吗
 害得我研究半天parser和wrapper as decorator

decorator
No.1
@decorator
class a:
     blablabla
insr = a(50)
No.2
a = decorator(a)
insr = a(50)


修饰器就是把class和另一个class wrapper bind起来
parameter是cls或者function（well python觉得世界全都是objects）
wrapper保护了enclosed class 又embed了instance（wrap）
可以帮助想改变世界的人给新的cls加更多的功能性又保护了封装的原来的世界



list = [1, 2, 4]
例子是计算count次数
def count（func）：
    def inner(*args, **kwargs):
    #functions' running times
      count = list[-1]
      func(*args, **kwargs)
      count -= 1
      return count
     return inner
 @count
 def sum(num):
    return math.sum(num)
 
 
 print(sum([1, 10]))
 
output: 
 11
 3
 
 
 This instance is like 省下力气？
 
 def do_twice(func):
    def wrapper_do_twice():
        func()
        func()
    return wrapper_do_twice
    
    
from module import do_twice
 
@do_twice
def loss_weight():
    print("瘦了!")
    
    
    
loss_weight()
瘦了！
瘦了！
